<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>背景音</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --text-primary: #fff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --glass: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.12);
            --accent-blue: #3b82f6;
            --accent-green: rgb(48, 209, 88);
            --accent-red: #ef4444;
            --ios-bg: rgba(30, 30, 30, 0.88);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text-primary);
            overflow: hidden;
            background: #1a1a1a;
        }

        /* 加载遮罩 */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(20, 20, 20, 0.95);
            -webkit-backdrop-filter: blur(30px);
            backdrop-filter: blur(30px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loader {
            width: 3.25em;
            transform-origin: center;
            animation: rotate4 2s linear infinite;
        }

        .loader circle {
            fill: none;
            stroke: hsl(214, 97%, 59%);
            stroke-width: 2;
            stroke-dasharray: 1, 200;
            stroke-dashoffset: 0;
            stroke-linecap: round;
            animation: dash4 1.5s ease-in-out infinite;
        }

        @keyframes rotate4 {
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes dash4 {
            0% {
                stroke-dasharray: 1, 200;
                stroke-dashoffset: 0;
            }

            50% {
                stroke-dasharray: 90, 200;
                stroke-dashoffset: -35px;
            }

            100% {
                stroke-dashoffset: -125px;
            }
        }

        .bg-layer {
            position: fixed;
            inset: 0;
            background-size: cover;
            background-position: center;
            transition: opacity 1.2s ease;
            opacity: 0;
            z-index: 1;
        }

        .bg-layer.active {
            opacity: 1;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.3) 0%,
                rgba(0, 0, 0, 0.5) 100%
            );
            z-index: 2;
        }

        .container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
            width: 100%;
            max-width: 500px;
        }

        .now-playing {
            text-align: center;
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeUp 0.8s ease 0.2s forwards;
        }

        .now-playing .label {
            font-size: 0.75rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .song-selector-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 2.8rem;
            font-weight: 300;
            letter-spacing: 2px;
            cursor: pointer;
            transition: opacity 0.3s ease;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .song-selector-btn:hover {
            opacity: 0.8;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 播放按钮 */
        .play-btn-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
            margin-bottom: 60px;
            opacity: 0;
            transform: scale(0.8);
            animation: scaleIn 0.6s ease 0.4s forwards;
        }

        /* 简化播放按钮模糊背景 - 伪元素修复版 */
        .play-btn {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 1px solid var(--glass-border);
            background: transparent; /* 背景移至伪元素 */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.4s ease, border-color 0.4s ease;
            position: relative;
            z-index: 3;
            color: #fff;
            overflow: hidden; /* 确保伪元素不溢出圆角 */
            transform: translateZ(0); /* 强制 GPU 加速，修复模糊渲染问题 */
        }

        /* 使用伪元素实现玻璃背景，避免层叠上下文问题 */
        .play-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--glass);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            z-index: -1;
            transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1), backdrop-filter 0.4s ease;
        }

        .play-btn.playing {
            color: var(--accent-blue);
            border-color: transparent;
        }

        .play-btn.playing::before {
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: none;
            backdrop-filter: none;
        }

        .play-btn svg {
            width: 48px;
            height: 48px;
        }

        /* 水波纹容器 */
        .ripple-container {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }

        .ripple {
            position: absolute;
            inset: -4px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.35);
            animation: rippleExpand 3s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(1.6); opacity: 0; }
        }

        @keyframes scaleIn {
            to { opacity: 1; transform: scale(1); }
        }

        /* 底部控制栏 */
        .bottom-controls {
            position: fixed;
            bottom: 36px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            background: transparent;
            border: none;
            color: var(--text-secondary);
        }

        .control-btn:hover {
            color: var(--text-primary);
        }

        .control-btn svg {
            width: 24px;
            height: 24px;
        }

        /* 倒计时显示 - 透明简洁风格 */
        .countdown-container {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            cursor: pointer;
        }

        .countdown-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .countdown-time {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .countdown-label {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .countdown-container.ending .countdown-time {
            color: #f87171;
        }

        .countdown-container.ending .countdown-label {
            color: rgba(248, 113, 113, 0.7);
        }

        /* iOS 风格 Action Sheet */
        .ios-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .ios-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .ios-menu {
            position: fixed;
            bottom: 20px;
            left: 10px;
            right: 10px;
            max-width: 400px;
            margin: 0 auto;
            z-index: 1001;
            transform: translateY(150%);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .ios-menu.show {
            transform: translateY(0);
        }

        .ios-menu-group {
            background: var(--ios-bg);
            -webkit-backdrop-filter: blur(40px);
            backdrop-filter: blur(40px);
            border-radius: 14px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .ios-menu-item {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: none;
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            color: var(--accent-blue);
            font-size: 1.1rem;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
            cursor: pointer;
            transition: background 0.15s ease;
            text-align: center;
        }

        .ios-menu-item:last-child {
            border-bottom: none;
        }

        .ios-menu-item.tapped {
            background: rgba(255, 255, 255, 0.12);
        }

        .ios-menu-item.danger {
            color: var(--accent-red);
        }

        /* iOS 音量滑块菜单 */
        .ios-volume-header {
            padding: 12px 16px 8px;
            text-align: center;
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
        }

        .ios-volume-title {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
            letter-spacing: 0.3px;
        }

        .ios-volume-container {
            padding: 14px 20px 18px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .ios-volume-icon {
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .ios-volume-icon svg {
            width: 18px;
            height: 18px;
            display: block;
        }

        .ios-volume-slider {
            flex: 1;
            height: 28px;
            display: flex;
            align-items: center;
            position: relative;
            cursor: pointer;
            touch-action: none;
        }

        .ios-volume-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .ios-volume-fill {
            height: 100%;
            background: var(--accent-green);
            border-radius: 2px;
        }

        .ios-volume-thumb {
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .ios-volume-thumb:active {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .ios-cancel {
            background: var(--ios-bg);
            -webkit-backdrop-filter: blur(40px);
            backdrop-filter: blur(40px);
            border-radius: 14px;
            width: 100%;
            padding: 16px;
            border: none;
            color: var(--accent-blue);
            font-size: 1.1rem;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
            cursor: pointer;
            text-align: center;
            transition: background 0.15s ease;
        }

        .ios-cancel.tapped {
            background: rgba(255, 255, 255, 0.08);
        }

        @media (max-width: 480px) {
            .song-selector-btn { font-size: 2.2rem; }
        }
    </style>
</head>
<body>
    <!-- 加载遮罩 -->
    <div class="loading-overlay" id="loadingOverlay">
        <svg class="loader" viewBox="25 25 50 50">
            <circle r="20" cy="50" cx="50"></circle>
        </svg>
    </div>

    <div id="bgContainer"></div>
    <div class="overlay"></div>

    <div class="container">
        <div class="now-playing">
            <div class="label">Now Playing</div>
            <button class="song-selector-btn" id="songSelectorBtn">Ocean</button>
        </div>

        <div class="play-btn-wrapper">
            <div class="ripple-container" id="rippleContainer"></div>
            <button class="play-btn" id="playBtn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M6 10a7 7 0 1 1 13 3.6a10 10 0 0 1-2 2a8 8 0 0 0-2 3A4.5 4.5 0 0 1 8.2 20"/><path d="M10 10a3 3 0 1 1 5 2.2"/></g></svg>
            </button>
        </div>
    </div>

    <!-- 底部控制栏 -->
    <div class="bottom-controls">
        <!-- 定时器 -->
        <button class="control-btn" id="timerBtn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M10 3q-.425 0-.712-.288T9 2t.288-.712T10 1h4q.425 0 .713.288T15 2t-.288.713T14 3zm2 11q.425 0 .713-.288T13 13V9q0-.425-.288-.712T12 8t-.712.288T11 9v4q0 .425.288.713T12 14m0 8q-1.85 0-3.488-.712T5.65 19.35t-1.937-2.863T3 13t.713-3.488T5.65 6.65t2.863-1.937T12 4q1.55 0 2.975.5t2.675 1.45l.7-.7q.275-.275.7-.275t.7.275t.275.7t-.275.7l-.7.7Q20 8.6 20.5 10.025T21 13q0 1.85-.713 3.488T18.35 19.35t-2.863 1.938T12 22m0-2q2.9 0 4.95-2.05T19 13t-2.05-4.95T12 6T7.05 8.05T5 13t2.05 4.95T12 20m0-7"/></svg>
        </button>

        <!-- 倒计时显示 -->
        <div class="countdown-container" id="countdownContainer">
            <span class="countdown-time" id="countdownTime">5 min</span>
            <span class="countdown-label">后停止播放</span>
        </div>

        <!-- 音量调节 -->
        <button class="control-btn" id="volumeBtn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M19 11.975q0-2.075-1.1-3.787t-2.95-2.563q-.375-.175-.55-.537t-.05-.738q.15-.4.538-.575t.787 0Q18.1 4.85 19.55 7.063T21 11.974t-1.45 4.913t-3.875 3.287q-.4.175-.788 0t-.537-.575q-.125-.375.05-.737t.55-.538q1.85-.85 2.95-2.562t1.1-3.788M7 15H4q-.425 0-.712-.288T3 14v-4q0-.425.288-.712T4 9h3l3.3-3.3q.475-.475 1.088-.213t.612.938v11.15q0 .675-.612.938T10.3 18.3zm9.5-3q0 1.05-.475 1.988t-1.25 1.537q-.25.15-.513.013T14 15.1V8.85q0-.3.263-.437t.512.012q.775.625 1.25 1.575t.475 2"/></svg>
        </button>
    </div>

    <!-- iOS 风格菜单 -->
    <div class="ios-overlay" id="iosOverlay"></div>
    <div class="ios-menu" id="iosMenu">
        <div class="ios-menu-group" id="iosMenuGroup"></div>
        <button class="ios-cancel" id="iosCancel">取消</button>
    </div>

    <script>
        const CACHE_NAME = 'bg-sound-cache-v1';
        const musicData = [
            { name: 'Ocean', file: 'Ocean.m4a', img: 'Ocean.jpg' },
            { name: 'Brown Noise', file: 'BrownNoise.m4a', img: 'BrownNoise.jpg' },
            { name: 'Pink Noise', file: 'PinkNoise.m4a', img: 'PinkNoise.jpg' },
            { name: 'Rain', file: 'Rain.m4a', img: 'Rain.jpg' },
            { name: 'Stream', file: 'Stream.m4a', img: 'Stream.jpg' },
            { name: 'White Noise', file: 'WhiteNoise.m4a', img: 'WhiteNoise.jpg' }
        ];

        const bgContainer = document.getElementById('bgContainer');
        const playBtn = document.getElementById('playBtn');
        const rippleContainer = document.getElementById('rippleContainer');
        const songSelectorBtn = document.getElementById('songSelectorBtn');
        const volumeBtn = document.getElementById('volumeBtn');
        const timerBtn = document.getElementById('timerBtn');
        const countdownContainer = document.getElementById('countdownContainer');
        const countdownTime = document.getElementById('countdownTime');
        const iosOverlay = document.getElementById('iosOverlay');
        const iosMenu = document.getElementById('iosMenu');
        const iosMenuGroup = document.getElementById('iosMenuGroup');
        const iosCancel = document.getElementById('iosCancel');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let audioContext = null;
        let gainNode = null;
        let currentSource = null;
        const audioBufferCache = {};

        // LocalStorage 存储实现
        const storage = {
            get(key, defaultValue) {
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : defaultValue;
                } catch (e) {
                    return defaultValue;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                } catch (e) {}
            }
        };

        function saveToStorage(key, value) {
            storage.set(key, value);
        }

        function loadFromStorage(key, defaultValue) {
            return storage.get(key, defaultValue);
        }

        let currentIndex = loadFromStorage('bg_currentIndex', 0);
        let baseVolume = loadFromStorage('bg_baseVolume', 0.8);
        let customTimers = loadFromStorage('bg_customTimers', []);
        
        let isPlaying = false;
        let isLoading = false;
        let switchId = 0;

        let timerInterval = null;
        let remainingSeconds = 0;
        const FADE_DURATION = 10;
        const CROSSFADE_TIME = 1.0;

        let rippleInterval = null;

        // 初始化背景
        musicData.forEach((item, index) => {
            const layer = document.createElement('div');
            layer.className = 'bg-layer' + (index === currentIndex ? ' active' : '');
            layer.style.backgroundImage = `url('img/${item.img}')`;
            bgContainer.appendChild(layer);
        });
        songSelectorBtn.textContent = musicData[currentIndex].name;

        // 资源预加载优化：只解码当前音频，其他仅获取并缓存
        async function preloadAllResources() {
            const cache = await caches.open(CACHE_NAME).catch(() => null);
            const imagePromises = [];
            const audioPromises = [];

            // 预加载图片
            musicData.forEach(item => {
                const imgUrl = `img/${item.img}`;
                const promise = new Promise((resolve) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = resolve;
                    img.src = imgUrl;
                });
                imagePromises.push(promise);
                if (cache) {
                    cache.match(imgUrl).then(resp => {
                        if (!resp) fetch(imgUrl).then(r => cache.put(imgUrl, r)).catch(() => {});
                    });
                }
            });

            // 预加载音频（仅 Fetch，不解码）
            for (const item of musicData) {
                const audioUrl = `music/${item.file}`;
                // 仅对当前音频进行解码预加载
                if (item === musicData[currentIndex]) {
                   initAudioContext();
                   audioPromises.push(loadAudioBuffer(audioUrl).catch(() => null));
                }
                
                if (cache) {
                    cache.match(audioUrl).then(resp => {
                        if (!resp) fetch(audioUrl).then(r => cache.put(audioUrl, r.clone())).catch(() => {});
                    });
                }
            }

            await Promise.all([...imagePromises, ...audioPromises]);
            loadingOverlay.classList.add('hidden');
        }

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                gainNode.connect(audioContext.destination);
            }
            if (audioContext.state === 'suspended') audioContext.resume();
        }

        async function loadAudioBuffer(url) {
            if (audioBufferCache[url]) return audioBufferCache[url];

            let response;
            try {
                const cache = await caches.open(CACHE_NAME);
                response = await cache.match(url);
            } catch (e) {}

            if (!response) {
                response = await fetch(url);
            }

            const arrayBuffer = await response.arrayBuffer();
            const buffer = await audioContext.decodeAudioData(arrayBuffer);
            audioBufferCache[url] = buffer;
            return buffer;
        }

        function createRipple() {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            rippleContainer.appendChild(ripple);
            ripple.addEventListener('animationend', () => ripple.remove());
        }

        function startRipples() {
            if (rippleInterval) return;
            createRipple();
            rippleInterval = setInterval(createRipple, 1000);
        }

        function stopRipples() {
            if (rippleInterval) {
                clearInterval(rippleInterval);
                rippleInterval = null;
            }
        }

        async function switchMusic(index) {
            if (currentIndex === index || isLoading) return;

            const thisSwitchId = ++switchId;
            initAudioContext();
            isLoading = true;
            songSelectorBtn.style.opacity = '0.5';

            const bgLayers = bgContainer.querySelectorAll('.bg-layer');
            bgLayers[currentIndex].classList.remove('active');
            bgLayers[index].classList.add('active');

            const prevIndex = currentIndex;
            currentIndex = index;
            saveToStorage('bg_currentIndex', currentIndex);
            songSelectorBtn.textContent = musicData[index].name;

            if (isPlaying && currentSource) {
                const now = audioContext.currentTime;
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + CROSSFADE_TIME);

                const oldSource = currentSource;
                currentSource = null;

                setTimeout(() => {
                    try { oldSource.stop(); oldSource.disconnect(); } catch(e) {}
                }, CROSSFADE_TIME * 1000);

                try {
                    const buffer = await loadAudioBuffer(`music/${musicData[index].file}`);

                    if (thisSwitchId !== switchId) {
                        isLoading = false;
                        songSelectorBtn.style.opacity = '1';
                        return;
                    }

                    await new Promise(r => setTimeout(r, CROSSFADE_TIME * 1000));

                    if (thisSwitchId !== switchId || !isPlaying) {
                        isLoading = false;
                        songSelectorBtn.style.opacity = '1';
                        return;
                    }

                    const newSource = audioContext.createBufferSource();
                    newSource.buffer = buffer;
                    newSource.loop = true;
                    newSource.connect(gainNode);
                    newSource.start(0);
                    currentSource = newSource;

                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + CROSSFADE_TIME);
                } catch(e) {
                    console.error('Failed to switch music:', e);
                } finally {
                    isLoading = false;
                    songSelectorBtn.style.opacity = '1';
                }
            } else {
                isLoading = false;
                songSelectorBtn.style.opacity = '1';
            }
        }

        async function togglePlay() {
            initAudioContext();
            const now = audioContext.currentTime;

            if (isPlaying) {
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + CROSSFADE_TIME);

                stopRipples();

                const oldSource = currentSource;
                currentSource = null;
                isPlaying = false;
                playBtn.classList.remove('playing');

                setTimeout(() => {
                    try { if (oldSource) { oldSource.stop(); oldSource.disconnect(); } } catch(e) {}
                }, CROSSFADE_TIME * 1000);
            } else {
                isLoading = true;
                songSelectorBtn.style.opacity = '0.5';
                loadingOverlay.classList.remove('hidden'); // 显示加载
                try {
                    const buffer = await loadAudioBuffer(`music/${musicData[currentIndex].file}`);
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.loop = true;
                    source.connect(gainNode);
                    source.start(0);
                    currentSource = source;

                    gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + CROSSFADE_TIME);

                    playBtn.classList.add('playing');
                    isPlaying = true;
                    startRipples();
                } finally { 
                    isLoading = false; 
                    songSelectorBtn.style.opacity = '1';
                    loadingOverlay.classList.add('hidden');
                }
            }
        }

        playBtn.onclick = togglePlay;

        function addTapEffect(element) {
            const addTap = () => element.classList.add('tapped');
            const removeTap = () => element.classList.remove('tapped');

            element.addEventListener('touchstart', addTap, { passive: true });
            element.addEventListener('touchend', removeTap, { passive: true });
            element.addEventListener('touchcancel', removeTap, { passive: true });
            element.addEventListener('mousedown', addTap);
            element.addEventListener('mouseup', removeTap);
            element.addEventListener('mouseleave', removeTap);
        }

        function showIOSMenu(items, onSelect, menuType = 'default') {
            iosMenuGroup.innerHTML = '';
            
            // 设置取消按钮文本
            if (menuType === 'volume') {
                iosCancel.textContent = '完成';
            } else {
                iosCancel.textContent = '取消';
            }

            if (menuType === 'volume') {
                const header = document.createElement('div');
                header.className = 'ios-volume-header';
                header.innerHTML = '<span class="ios-volume-title">音量调节</span>';
                iosMenuGroup.appendChild(header);

                const volumeContainer = document.createElement('div');
                volumeContainer.className = 'ios-volume-container';
                volumeContainer.innerHTML = `
                    <div class="ios-volume-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M7 15H4q-.425 0-.712-.288T3 14v-4q0-.425.288-.712T4 9h3l3.3-3.3q.475-.475 1.088-.213t.612.938v11.15q0 .675-.612.938T10.3 18.3z"/></svg>
                    </div>
                    <div class="ios-volume-slider" id="iosVolumeSlider">
                        <div class="ios-volume-track">
                            <div class="ios-volume-fill" id="iosVolumeFill"></div>
                        </div>
                        <div class="ios-volume-thumb" id="iosVolumeThumb"></div>
                    </div>
                    <div class="ios-volume-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M19 11.975q0-2.075-1.1-3.787t-2.95-2.563q-.375-.175-.55-.537t-.05-.738q.15-.4.538-.575t.787 0Q18.1 4.85 19.55 7.063T21 11.974t-1.45 4.913t-3.875 3.287q-.4.175-.788 0t-.537-.575q-.125-.375.05-.737t.55-.538q1.85-.85 2.95-2.562t1.1-3.788M7 15H4q-.425 0-.712-.288T3 14v-4q0-.425.288-.712T4 9h3l3.3-3.3q.475-.475 1.088-.213t.612.938v11.15q0 .675-.612.938T10.3 18.3zm9.5-3q0 1.05-.475 1.988t-1.25 1.537q-.25.15-.513.013T14 15.1V8.85q0-.3.263-.437t.512.012q.775.625 1.25 1.575t.475 2"/></svg>
                    </div>
                `;
                iosMenuGroup.appendChild(volumeContainer);

                setTimeout(() => {
                    const slider = document.getElementById('iosVolumeSlider');
                    const fill = document.getElementById('iosVolumeFill');
                    const thumb = document.getElementById('iosVolumeThumb');

                    function updateVolumeUI(percent) {
                        const pct = (percent * 100) + '%';
                        fill.style.width = pct;
                        thumb.style.left = pct;
                    }

                    function handleVolumeChange(e) {
                        const rect = slider.getBoundingClientRect();
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));

                        baseVolume = percent;
                        saveToStorage('bg_baseVolume', baseVolume);
                        updateVolumeUI(percent);

                        if (isPlaying && gainNode && audioContext && (remainingSeconds <= 0 || remainingSeconds > FADE_DURATION)) {
                            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                            gainNode.gain.setValueAtTime(baseVolume, audioContext.currentTime);
                        }
                    }

                    updateVolumeUI(baseVolume);

                    slider.addEventListener('mousedown', (e) => {
                        handleVolumeChange(e);
                        const move = (ev) => { ev.preventDefault(); handleVolumeChange(ev); };
                        const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
                        document.addEventListener('mousemove', move);
                        document.addEventListener('mouseup', up);
                    });

                    slider.addEventListener('touchstart', (e) => {
                        handleVolumeChange(e);
                        const move = (ev) => handleVolumeChange(ev);
                        const end = () => { document.removeEventListener('touchmove', move); document.removeEventListener('touchend', end); };
                        document.addEventListener('touchmove', move, { passive: true });
                        document.addEventListener('touchend', end);
                    }, { passive: true });
                }, 0);
            } else if (menuType === 'countdown') {
                const btn = document.createElement('button');
                btn.className = 'ios-menu-item danger';
                btn.textContent = '停止定时';
                addTapEffect(btn);
                btn.onclick = () => { clearTimer(); hideIOSMenu(); };
                iosMenuGroup.appendChild(btn);
            } else {
                items.forEach(item => {
                    const btn = document.createElement('button');
                    btn.className = 'ios-menu-item' + (item.className ? ' ' + item.className : '');
                    btn.textContent = item.label;
                    addTapEffect(btn);
                    btn.onclick = () => { onSelect(item.value); hideIOSMenu(); };
                    iosMenuGroup.appendChild(btn);
                });
            }

            iosOverlay.classList.add('show');
            iosMenu.classList.add('show');
        }

        function hideIOSMenu() {
            iosOverlay.classList.remove('show');
            iosMenu.classList.remove('show');
        }

        addTapEffect(iosCancel);
        iosCancel.onclick = iosOverlay.onclick = hideIOSMenu;

        songSelectorBtn.onclick = () => {
            const items = musicData.map((m, i) => ({ label: m.name, value: i }));
            showIOSMenu(items, switchMusic);
        };

        timerBtn.onclick = () => {
            const defaultTimers = [
                { label: '15 分钟', value: 15 },
                { label: '30 分钟', value: 30 },
                { label: '1 小时', value: 60 }
            ];
            
            const items = [...defaultTimers, ...customTimers].map(t => ({
                label: t.label || `${t.value} 分钟`,
                value: t.value
            }));
            
            items.push({ label: '添加定时器', value: 'add_custom', className: 'add-timer' });
            
            showIOSMenu(items, (val) => {
                if (val === 'add_custom') {
                    handleAddTimer();
                } else {
                    startTimer(val);
                }
            });
        };
        
        function handleAddTimer() {
            // 使用 setTimeout 确保菜单关闭后再弹出提示
            setTimeout(() => {
                const durationStr = prompt('请输入定时时长（分钟）：');
                if (!durationStr) return;
                
                const duration = parseInt(durationStr);
                if (isNaN(duration) || duration <= 0) {
                    alert('请输入有效的分钟数');
                    return;
                }
                
                let label = prompt('请输入别名（可选）：');
                if (!label) label = `${duration} 分钟`;
                
                customTimers.push({ label, value: duration });
                saveToStorage('bg_customTimers', customTimers);
                
                // 重新打开菜单
                timerBtn.click();
            }, 300);
        }

        volumeBtn.onclick = () => {
            showIOSMenu([], null, 'volume');
        };

        countdownContainer.onclick = () => {
            showIOSMenu([], null, 'countdown');
        };

        function startTimer(minutes) {
            if (timerInterval) clearInterval(timerInterval);
            remainingSeconds = minutes * 60;
            updateCountdownUI();
            countdownContainer.classList.add('visible');
            countdownContainer.classList.remove('ending');

            timerInterval = setInterval(() => {
                remainingSeconds--;
                if (remainingSeconds <= 0) {
                    if (isPlaying) togglePlay();
                    clearTimer();
                } else {
                    if (remainingSeconds <= FADE_DURATION && isPlaying && gainNode && audioContext) {
                        const ratio = remainingSeconds / FADE_DURATION;
                        gainNode.gain.setValueAtTime(baseVolume * ratio, audioContext.currentTime);
                        countdownContainer.classList.add('ending');
                    }
                    updateCountdownUI();
                }
            }, 1000);
        }

        function clearTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            remainingSeconds = 0;
            countdownContainer.classList.remove('visible', 'ending');
            if (isPlaying && gainNode && audioContext) {
                gainNode.gain.setValueAtTime(baseVolume, audioContext.currentTime);
            }
        }

        function updateCountdownUI() {
            const m = Math.floor(remainingSeconds / 60);
            countdownTime.textContent = `${m} min`;
        }

        preloadAllResources();
    </script>
</body>
</html>
